
# (1) Bytecode commpiler (haskell) + VM (Haskell)
#exe-under-test : ../src/lox.exe : ln $in $out
#deps-for-exe-under-test : : touch $@

# (2) Bytecode commpiler (haskell) + export to VM (C)
exe-under-test: my-lox.sh : ln $in $out
deps-for-exe-under-test:
  echo ../src/lox.exe >> $out
  echo ../c/vm.exe >> $out

my-lox.sh:
  #echo './lox.exe -tree $$@' >> $out
  echo './lox.exe -bci $$@' >> $out
  #echo './lox.exe -export code.bin $$@ && ./vm.exe code.bin' >> $out
  chmod +x $out

chapters:
  echo chap8.list  >> $out  #        69
  echo chap9.list  >> $out  # +27 =  96  # 11 fails remain in vm.c
  echo chap10.list >> $out  # +43 = 139
  #echo chap11.list >> $out  #  +8 = 147
  #echo chap12.list >> $out  # +60 = 207
  #echo chap13.list >> $out  # +32 = 239

groups:
  echo parse-error.list          >> $out  #  40
  echo resolve-error.list        >> $out  #  12
  echo runtime-error.list        >> $out  #  61
  echo successful-execution.list >> $out  # 127
                                          #-----
                                          # 239

# Tests are organized by chapter increments, or logical groups

fullpath.list: @chapters
  cat *.list | sed 's/#.*//' | grep -v '^ *$$' | sed 's|^|~/other/craftinginterpreters/|' > $out
  #echo ./lambda.lox >> $out
  #echo ./fib-iter.lox >> $out
  echo ./thrice.lox >> $out

lambda.lox : ../examples/lambda.lox :
fib-iter.lox : ../examples/fib-iter.lox :
thrice.lox : ../examples/thrice.lox :

rules : fullpath.list rules.sh #args-for-exe-under-test
  ./rules.sh < $in > $out

include rules

reference-lox : ~/other/craftinginterpreters/clox : ln $in $out
